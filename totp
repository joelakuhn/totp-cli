#!/usr/bin/env php
<?php

class Base32 {
  const DECODE_ALPHABET = [
    0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
    0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  ];

  const ENCODE_APHABET = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', '2', '3', '4', '5', '6', '7',
  ];

  public static function decode($str, $alphabet = self::DECODE_ALPHABET) {
    $result = '';
    $byte = 0;
    $offset = 0;
    foreach (str_split($str) as $c) {
      $val = $alphabet[ord($c)];

      $shift = (8 - $offset) - 5;
      if ($shift < 0) $byte |= $val >> abs($shift);
      else $byte |= $val << $shift;

      $offset += 5;
      if ($offset >= 8) {
        $result .= chr($byte);
        $offset -= 8;
        $byte = $val << (8 - $offset) & 0xff;
      }
    }
    return $result;
  }

  public static function encode($str, $alphabet = self::ENCODE_APHABET) {
    $result = '';
    $working = 0;
    $working_n = 0;
    $count = 0;
    foreach (str_split($str) as $c) {
      $working = ($working << 8) + ord($c);
      $working_n += 8;
      while ($working_n >= 5) {
        $result .= $alphabet[$working >> ($working_n - 5)];
        $working_n -= 5;
        $working &= 0xFF >> (8 - $working_n);
        $count += 1;
      }
    }
    if ($working !== 0) {
      $result .= $alphabet[$working << (5 - $working_n)];
      $count += 1;
      if ($count % 8 !== 0) {
        for ($i=0; $i<(8 - ($count % 8)); $i++) {
          $result .= '=';
        }
      }
    }
    return $result;
  }
}

function otp($secret, $len = 6, $period = 30) {
  $decoded_secret = Base32::decode($secret);
  if ($decoded_secret === null) return null;

  $counter = floor(time() / $period);
  $digest = hash_hmac('sha1', pack('J', $counter), $decoded_secret, true);
  $offset = unpack("C", substr($digest, 19, 1))[1] & 0x0F;
  $hotp = unpack("N", substr($digest, $offset, 4))[1] & 0x7FFFFFFF;

  return str_pad(substr($hotp, -$len, $len), $len, '0', STR_PAD_LEFT);
}

function interactive_add() {
  echo "name: ";
  $name = trim(fgets(STDIN));
  echo "keyphrase: ";
  $secret = trim(fgets(STDIN));
  echo "passphrase length [6]: ";
  $length = trim(fgets(STDIN)) ?: '6';
  echo "period [30]: ";
  $period = trim(fgets(STDIN)) ?: '30';
  
  file_put_contents("{$_SERVER['HOME']}/.totp/{$name}.ini", <<<EOF
  [totp]
  name={$name}
  secret={$secret}
  length={$length}
  period={$period}

  EOF);
}

function eval_ini_config($path) {
  $conf = parse_ini_file($path);
  if (isset($conf['secret'])) {
    $secret = $conf['secret'];
    $length = $conf['length'] ?? 6;
    $period = $conf['period'] ?? 30;
    return otp($secret, $length, $period);
  }
}

function eval_txt_config($path) {
  return otp(trim(file_get_contents($path)));
}

function eval_config($name) {
  if (file_exists($name)) {
    return otp(trim(file_get_contents($name)));
  }
  else {
    $txt_path = "{$_SERVER['HOME']}/.totp/{$name}.txt";
    if (file_exists($txt_path)) {
      return eval_txt_config($txt_path);
    }
    $ini_path = "{$_SERVER['HOME']}/.totp/{$name}.ini";
    if (file_exists($ini_path)) {
      return eval_ini_config($ini_path);
    }
  }
}

function eval_all() {
  foreach (get_configs() as $config) {
    echo str_pad($config . ':', 16) . eval_config($config) . "\n";
  }
}

function get_configs() {
  $configs = [];
  $dh = opendir("{$_SERVER['HOME']}/.totp/");
  while ($file = readdir($dh)) {
    if (substr($file, 0, 1) === '.') continue;
    $configs[] = pathinfo($file, PATHINFO_FILENAME);
  }
  sort($configs);
  return $configs;
}

function list_configs() {
  foreach (get_configs() as $config) {
    echo "$config\n";
  }
}

if (isset($argv[1])) {
  $args = array_slice($argv, 1);
  foreach ($args as $arg) {
    if ($arg === 'add') {
      interactive_add();
    }
    else if ($arg === 'list') {
      list_configs();
    }
    else if ($arg === 'all') {
      eval_all();
    }
    else {
      if ($totp = eval_config($arg)) {
        if (count($args) > 1) echo str_pad($arg . ':', 16);
        echo "{$totp}\n";
      }
      else {
        echo "No config for $arg";
      }
    }
  }
}
else {
  echo "Usage:\n";
  echo "totp <name>   Generate code for named configuration\n";
  echo "totp add      Interactively add a configuration\n";
  echo "totp list     List configurations\n";
  echo "totp all      Generate codes for all configurations\n";
}
